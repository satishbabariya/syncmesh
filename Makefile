.PHONY: build test clean proto docker up down logs

# Variables
BINARY_NAME=syncmesh
VERSION?=1.0.0
BUILD_TIME=$(shell date +%Y-%m-%dT%H:%M:%S%z)
GIT_COMMIT=$(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")

# Build flags
LDFLAGS=-ldflags "-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME) -X main.GitCommit=$(GIT_COMMIT)"

# Default target
all: proto build

# Build the application
build:
	@echo "Building $(BINARY_NAME)..."
	CGO_ENABLED=0 go build $(LDFLAGS) -o $(BINARY_NAME) ./main.go

# Build for multiple platforms
build-all:
	@echo "Building for multiple platforms..."
	GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build $(LDFLAGS) -o $(BINARY_NAME)-linux-amd64 ./main.go
	GOOS=darwin GOARCH=amd64 CGO_ENABLED=0 go build $(LDFLAGS) -o $(BINARY_NAME)-darwin-amd64 ./main.go
	GOOS=windows GOARCH=amd64 CGO_ENABLED=0 go build $(LDFLAGS) -o $(BINARY_NAME)-windows-amd64.exe ./main.go

# Generate protocol buffers
proto:
	@echo "Generating protocol buffers..."
	@mkdir -p pkg/proto
	# Note: In a real implementation, you would run:
	# protoc --go_out=. --go-grpc_out=. pkg/proto/*.proto
	# For now, we'll create mock implementations

# Create mock proto files for compilation
proto-mock:
	@echo "Creating mock proto implementations..."
	@mkdir -p pkg/proto
	@cat > pkg/proto/proto.go << 'EOF'
// Code generated by protoc-gen-go. DO NOT EDIT.
package proto

// Mock implementations for protocol buffers
// In a real implementation, these would be generated from .proto files

// FileSync service interface
type UnimplementedFileSyncServer struct{}

func (UnimplementedFileSyncServer) SyncFile(ctx interface{}, req *SyncFileRequest) (*SyncFileResponse, error) {
	return nil, nil
}

func (UnimplementedFileSyncServer) GetFileStatus(ctx interface{}, req *GetFileStatusRequest) (*GetFileStatusResponse, error) {
	return nil, nil
}

func (UnimplementedFileSyncServer) StreamFileData(stream interface{}) error {
	return nil
}

func (UnimplementedFileSyncServer) WatchFiles(req *WatchFilesRequest, stream interface{}) error {
	return nil
}

// Cluster service interface
type UnimplementedClusterServer struct{}

func (UnimplementedClusterServer) JoinCluster(ctx interface{}, req *JoinClusterRequest) (*JoinClusterResponse, error) {
	return nil, nil
}

func (UnimplementedClusterServer) LeaveCluster(ctx interface{}, req *LeaveClusterRequest) (*LeaveClusterResponse, error) {
	return nil, nil
}

func (UnimplementedClusterServer) GetClusterStatus(ctx interface{}, req *GetClusterStatusRequest) (*GetClusterStatusResponse, error) {
	return nil, nil
}

func (UnimplementedClusterServer) StreamClusterEvents(req *StreamClusterEventsRequest, stream interface{}) error {
	return nil
}

// Message types - normally generated from proto files
type SyncFileRequest struct {
	FilePath  string
	Operation string
	Data      []byte
	Checksum  string
	Size      int64
	ModTime   int64
	FromNode  string
	Version   uint64
	Metadata  map[string]string
}

type SyncFileResponse struct {
	Success   bool
	Message   string
	ErrorCode string
	Version   uint64
}

type GetFileStatusRequest struct {
	FilePath string
}

type GetFileStatusResponse struct {
	Exists   bool
	Size     int64
	Checksum string
	ModTime  int64
	Version  uint64
	Status   string
	Metadata map[string]string
}

type FileChunk struct {
	FileName    string
	ChunkNumber int32
	Data        []byte
	Checksum    string
	IsLast      bool
	TotalSize   int64
}

type StreamFileResponse struct {
	Success      bool
	Message      string
	BytesWritten int64
	ErrorCode    string
}

type WatchFilesRequest struct {
	Patterns        []string
	IncludeExisting bool
}

type FileEvent struct {
	FilePath  string
	Operation string
	Timestamp int64
	Size      int64
	Checksum  string
	Version   uint64
	Metadata  map[string]string
}

type JoinClusterRequest struct {
	NodeId   string
	Address  string
	Version  string
	Metadata map[string]string
}

type JoinClusterResponse struct {
	Success  bool
	Message  string
	LeaderId string
	Nodes    []*ClusterNode
}

type LeaveClusterRequest struct {
	NodeId string
	Reason string
}

type LeaveClusterResponse struct {
	Success bool
	Message string
}

type GetClusterStatusRequest struct {
	IncludeDetails bool
}

type GetClusterStatusResponse struct {
	LeaderId    string
	Nodes       []*ClusterNode
	TotalNodes  int32
	ActiveNodes int32
	Health      *ClusterHealth
}

type StreamClusterEventsRequest struct {
	EventTypes []string
}

type ClusterNode struct {
	NodeId    string
	Address   string
	Status    string
	IsLeader  bool
	Version   string
	LastSeen  int64
	JoinedAt  int64
	Metadata  map[string]string
}

type ClusterEvent struct {
	Type      string
	NodeId    string
	Timestamp int64
	Data      map[string]string
}

type ClusterHealth struct {
	Status    string
	Checks    []*HealthCheck
	LastCheck int64
}

type HealthCheck struct {
	Name       string
	Status     string
	Message    string
	LastCheck  int64
	DurationMs int64
}

// Service registration functions (normally generated)
func RegisterFileSyncServer(s interface{}, srv interface{}) {}
func RegisterClusterServer(s interface{}, srv interface{}) {}

// Client interfaces (normally generated)
type FileSync_StreamFileDataServer interface{}
type FileSync_WatchFilesServer interface{}
type Cluster_StreamClusterEventsServer interface{}
EOF

# Test the application
test:
	@echo "Running tests..."
	go test -v ./...

# Test with coverage
test-coverage:
	@echo "Running tests with coverage..."
	go test -v -coverprofile=coverage.out ./...
	go tool cover -html=coverage.out -o coverage.html

# Lint the code
lint:
	@echo "Running linter..."
	golangci-lint run

# Clean build artifacts
clean:
	@echo "Cleaning..."
	rm -f $(BINARY_NAME)
	rm -f $(BINARY_NAME)-*
	rm -f coverage.out coverage.html
	docker-compose down -v
	docker system prune -f

# Docker operations
docker:
	@echo "Building Docker image..."
	docker build -t syncmesh:$(VERSION) .
	docker tag syncmesh:$(VERSION) syncmesh:latest

# Start the cluster with docker-compose
up:
	@echo "Starting cluster..."
	docker-compose up -d

# Stop the cluster
down:
	@echo "Stopping cluster..."
	docker-compose down

# View logs
logs:
	docker-compose logs -f

# Show cluster status
status:
	@echo "Checking cluster status..."
	@curl -s http://localhost:8080/api/v1/cluster/status | jq '.' || echo "Cluster not responding"

# Show health status
health:
	@echo "Checking health..."
	@curl -s http://localhost:8080/api/v1/health | jq '.' || echo "Health endpoint not responding"

# Initialize development environment
dev-setup:
	@echo "Setting up development environment..."
	go mod download
	go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
	# go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
	# go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest

# Run the application locally
run:
	@echo "Running $(BINARY_NAME)..."
	./$(BINARY_NAME) --config config.yaml

# Install the application
install: build
	@echo "Installing $(BINARY_NAME)..."
	cp $(BINARY_NAME) $(GOPATH)/bin/

# Show help
help:
	@echo "Available targets:"
	@echo "  build         - Build the application"
	@echo "  build-all     - Build for multiple platforms"
	@echo "  proto         - Generate protocol buffers"
	@echo "  proto-mock    - Create mock proto implementations"
	@echo "  test          - Run tests"
	@echo "  test-coverage - Run tests with coverage"
	@echo "  lint          - Run linter"
	@echo "  clean         - Clean build artifacts"
	@echo "  docker        - Build Docker image"
	@echo "  up            - Start cluster with docker-compose"
	@echo "  down          - Stop cluster"
	@echo "  logs          - View cluster logs"
	@echo "  status        - Check cluster status"
	@echo "  health        - Check health status"
	@echo "  dev-setup     - Set up development environment"
	@echo "  run           - Run the application locally"
	@echo "  install       - Install the application"
	@echo "  help          - Show this help"